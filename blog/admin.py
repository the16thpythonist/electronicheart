from django.contrib import admin
from django.contrib.admin import ModelAdmin
from django.forms import ModelForm
from django.contrib.contenttypes.admin import GenericTabularInline

from django_summernote.admin import SummernoteModelAdmin

from .models import Tutorial, Project, JupyterNotebook
from .models import Comment

# Useful resources:
# https://docs.djangoproject.com/en/3.2/ref/contrib/admin/
# https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Admin_site


class CommentInline(GenericTabularInline):

    model = Comment
    fields = ['name', 'email', 'content', 'author', 'active']
    extra = 1
    ct_field = 'content_type'
    ct_fk_field = 'object_id'


class EntryAdmin(SummernoteModelAdmin):

    list_display = ('title', 'author', 'creation_date', 'comment_count')
    fieldsets = [
        ('Meta Information', {
            'fields': [('title', 'subtitle'), 'description', 'thumbnail'],
        }),
        ('Content', {
            'fields': ['content']
        }),
        ('Autogenerated', {
            'classes': [],
            'fields': [('creation_date', 'publishing_date'), 'slug']
        })
    ]
    inlines = [CommentInline]
    summernote_fields = '__all__'


class ProjectAdmin(EntryAdmin):
    pass


class TutorialAdmin(EntryAdmin):
    pass


class JupyterNotebookAdmin(ModelAdmin):

    list_display = ('title', 'subtitle', 'publishing_date')
    fieldsets = [
        ('Meta Information', {
            'fields': [('title', 'subtitle'), 'description', 'thumbnail'],
        }),
        ('Jupyter Notebook', {
            'fields': ['jupyter_file', 'html_file']
        }),
        ('Content', {
            'fields': ['content']
        }),
        ('Autogenerated', {
            'classes': [],
            'fields': [('creation_date', 'publishing_date'), 'slug']
        })
    ]
    inlines = [CommentInline]


class CommentAdmin(ModelAdmin):

    # One thing to note here is that this list does not contain the "entry" field. This is because this is a generic
    # foreign key. These can apparently not be simply rendered (or even queried) as they are. This means when editing
    # a comment in the admin backend there is not simple way to just have dropdown menu to select which post to assign
    # this comment to. I think it would be possible, but it would be a bit more effort. For now a workaround is to have
    # the two fields 'content_type' and 'object_id' (Those actually make up the 'entry' field.
    fields = [
        'name',
        'email',
        'hash_id',
        'author',
        'image',
        'content',
        'publishing_date',
        'active',
        # 'entry' does not work!
        ('content_type', 'object_id')
    ]
    # https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Admin_site
    # This is actually a sick functionality! As you can see with the name "get_shortened_content" is actually a method
    # but we can use the output of this method to fill a column in the list display! In this case the column contains
    # the first few characters of the content.
    list_display = ('name', 'publishing_date', 'get_shortened_content')


admin.site.register(Tutorial, TutorialAdmin)
admin.site.register(Project, ProjectAdmin)
admin.site.register(JupyterNotebook, JupyterNotebookAdmin)

admin.site.register(Comment, CommentAdmin)
